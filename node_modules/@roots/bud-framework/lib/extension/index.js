var _a, _b, _c, _d;
import { __decorate, __metadata } from "tslib";
import { bind } from '@roots/bud-support/decorators';
import has from '@roots/bud-support/lodash/has';
import isFunction from '@roots/bud-support/lodash/isFunction';
import isUndefined from '@roots/bud-support/lodash/isUndefined';
/**
 * Bud extension
 */
export class Extension {
    /**
     * Function returning a boolean indicating if the {@link Extension} should be utilized.
     *
     * @remarks
     * By default returns {@link Extension.enabled}
     *
     * @public
     */
    async when(_app, _options) {
        return !isUndefined(this.enabled) ? this.enabled : true;
    }
    /**
     * Class constructor
     *
     * @public
     */
    constructor(app) {
        /**
         * Extension is enabled
         */
        this.enabled = undefined;
        /**
         * Extension options
         *
         * @internal
         */
        this.optionsMap = {};
        /**
         * Extension meta
         *
         * @public
         */
        this.meta = {
            init: false,
            register: false,
            boot: false,
            configAfter: false,
            buildBefore: false,
            buildAfter: false,
        };
        this._app = () => app;
        Object.defineProperty(this, `app`, {
            get: () => this._app(),
        });
        Object.defineProperty(this, `logger`, {
            get: () => app.context.logger.make(this.app.label, this.label ?? `anonymous extension`),
        });
        const opts = this.options ?? {};
        Object.defineProperty(this, `options`, {
            get: this.getOptions,
            set: this.setOptions,
        });
        this.setOptions(opts);
    }
    /**
     * `init` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    async _init() {
        if (isUndefined(this.init))
            return;
        this.logger.log(`initialized`);
        try {
            await this.init(this.app, this.options);
            this.meta[`init`] = true;
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * `register` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    async _register() {
        if (isUndefined(this.register))
            return;
        if (!this.meta[`init`])
            await this._init();
        try {
            await this.register(this.app, this.options);
            this.meta[`register`] = true;
        }
        catch (error) {
            throw error;
        }
        this.logger.success(`registered`);
    }
    /**
     * `boot` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    async _boot() {
        if (isUndefined(this.boot))
            return;
        if (!this.meta[`init`])
            await this._init();
        if (!this.meta[`register`])
            await this._register();
        try {
            await this.boot(this.app, this.options);
            this.meta[`boot`] = true;
        }
        catch (error) {
            throw error;
        }
        this.logger.success(`booted`);
    }
    /**
     * `buildBefore` callback handler
     *
     * @public
     */
    async _buildBefore() {
        const enabled = await this.isEnabled();
        if (isUndefined(this.buildBefore) || enabled === false)
            return;
        this.logger.info(`buildBefore:`, this.label ?? this.constructor.name ?? `anonymous extension`);
        this.meta[`buildBefore`] = true;
        await this.buildBefore(this.app, this.options);
    }
    /**
     * `buildAfter` callback handler
     *
     * @public
     */
    async _buildAfter() {
        const enabled = await this.isEnabled();
        if (isUndefined(this.buildAfter) || enabled === false)
            return;
        this.logger.info(`buildAfter:`, this.label ?? this.constructor.name ?? `anonymous extension`);
        this.logger.log(`buildAfter`);
        this.meta[`buildAfter`] = true;
        await this.buildAfter(this.app, this.options);
    }
    /**
     * `configAfter` callback handler
     *
     * @public
     */
    async _configAfter() {
        const enabled = await this.isEnabled();
        if (isUndefined(this.configAfter) || enabled === false)
            return;
        this.logger.log(`configAfter`);
        this.meta[`configAfter`] = true;
        await this.configAfter(this.app, this.options);
    }
    /**
     * `make` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    async _make() {
        if (isUndefined(this.make) && isUndefined(this.plugin)) {
            return false;
        }
        const enabled = await this.isEnabled();
        if (enabled === false) {
            return false;
        }
        try {
            if (!isUndefined(this.apply)) {
                this.logger.info(`apply prop found. return extension instance`);
                return this;
            }
        }
        catch (error) {
            this.logger.error(`error instantiating plugin`, error);
        }
        try {
            if (!isUndefined(this.plugin)) {
                const plugin = new this.plugin(this.options);
                this.logger.success(`produced webpack plugin`);
                return plugin;
            }
        }
        catch (err) {
            this.logger.error(`error instantiating plugin`, err);
        }
        try {
            if (!isUndefined(this.make)) {
                const plugin = await this.make(this.app, this.options);
                this.logger.success(`produced webpack plugin`);
                return plugin;
            }
        }
        catch (err) {
            this.logger.error(`error calling make`, err);
        }
    }
    /**
     * Get extension options
     *
     * @public
     * @decorator `@bind`
     */
    getOptions() {
        return Object.entries(this.optionsMap ?? {}).reduce(this.fromOptionsMap, {});
    }
    /**
     * Set extension options
     *
     * @public
     * @decorator `@bind`
     */
    setOptions(value) {
        this.optionsMap = isFunction(value) ? value(this.options) : value;
        return this;
    }
    /**
     * Get extension option
     *
     * @public
     * @decorator `@bind`
     */
    getOption(key) {
        return this.options[key];
    }
    /**
     * Set extension option
     *
     * @public
     * @decorator `@bind`
     */
    setOption(key, value) {
        if (!this.optionsMap)
            this.optionsMap = {};
        this.optionsMap[key] = isFunction(value)
            ? value(this.options[key])
            : () => value;
        return this;
    }
    /**
     * Normalize options to functions
     *
     * @public
     * @decorator `@bind`
     */
    toOptionsMap(funcMap = {}, [key, value]) {
        return {
            ...funcMap,
            [key]: isFunction(value) ? value : () => value,
        };
    }
    /**
     * Get options from function map
     *
     * @public
     * @decorator `@bind`
     */
    fromOptionsMap(options, [key, value]) {
        return {
            ...(options ?? {}),
            [key]: isFunction(value) ? value(this.app) : value,
        };
    }
    /**
     * Assign properties from an object
     *
     * @public
     * @decorator `@bind`
     */
    fromObject(extensionObject) {
        extensionObject &&
            Object.entries(extensionObject).map(([k, v]) => {
                this[k] = v;
            });
        return this;
    }
    /**
     * Returns true if extension property is set
     *
     * @param key - property name
     * @returns true if property exists on extension
     *
     * @public
     * @decorator `@bind`
     */
    has(key) {
        return has(this, key);
    }
    /**
     * Returns true if extension property is set and is a function
     *
     * @param key - property name
     * @returns true if property exists on extension
     *
     * @public
     * @decorator `@bind`
     */
    isFunction(key) {
        return this.has(key) && isFunction(this[key]) ? true : false;
    }
    /**
     * Resolve module using `import.meta.resolve` api
     *
     * @remarks
     * Uses `import-meta-resolve` (npm package).
     * Will transition to node `import.meta.resolve` api when it is marked
     * non-experimental. It currently requires a flag to enable.
     *
     * @public
     * @decorator `@bind`
     */
    async resolve(signifier, context) {
        let modulePath;
        modulePath = await this.app.module.resolve(signifier);
        if (!modulePath && context) {
            modulePath = await this.app.module.resolve(signifier, context);
        }
        if (!modulePath) {
            const error = new Error(`could not resolve ${signifier}`);
            error.name = `Extension Dependency Error`;
            throw error;
        }
        return modulePath;
    }
    /**
     * Import ESM module
     *
     * @public
     * @decorator `@bind`
     */
    async import(signifier, context) {
        try {
            const path = await this.resolve(signifier);
            if (!path) {
                this.logger.error(`could not import`, signifier);
                return;
            }
            const result = await this.app.module.import(path);
            if (!result) {
                this.logger.error(`could not import`, signifier);
                return;
            }
            this.logger.success(`imported`, signifier);
            return result?.default ?? result ?? undefined;
        }
        catch (error) {
            this.logger.error(`error importing`, signifier);
        }
    }
    /**
     * Disable extension
     *
     * @public
     * @decorator `@bind`
     */
    disable() {
        this.enabled = false;
    }
    /**
     * Enable extension
     *
     * @public
     * @decorator `@bind`
     */
    enable(enabled = true) {
        this.enabled = enabled;
        return this;
    }
    /**
     * Value determining if the extension should be utilized
     *
     * @public
     * @decorator `@bind`
     */
    async isEnabled() {
        if (!isUndefined(this.enabled))
            return this.enabled;
        if (isFunction(this.when))
            return await this.when(this.app, this.options);
        return true;
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_init", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_register", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_boot", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_buildBefore", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_buildAfter", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_configAfter", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_make", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], Extension.prototype, "getOptions", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Object)
], Extension.prototype, "setOptions", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_a = typeof K !== "undefined" && K) === "function" ? _a : Object]),
    __metadata("design:returntype", Object)
], Extension.prototype, "getOption", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof K !== "undefined" && K) === "function" ? _b : Object, Object]),
    __metadata("design:returntype", Object)
], Extension.prototype, "setOption", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Array]),
    __metadata("design:returntype", Object)
], Extension.prototype, "toOptionsMap", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Array]),
    __metadata("design:returntype", Object)
], Extension.prototype, "fromOptionsMap", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Object)
], Extension.prototype, "fromObject", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof K !== "undefined" && K) === "function" ? _c : Object]),
    __metadata("design:returntype", Boolean)
], Extension.prototype, "has", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof K !== "undefined" && K) === "function" ? _d : Object]),
    __metadata("design:returntype", Boolean)
], Extension.prototype, "isFunction", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], Extension.prototype, "resolve", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], Extension.prototype, "import", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], Extension.prototype, "disable", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Extension.prototype, "enable", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "isEnabled", null);
//# sourceMappingURL=index.js.map