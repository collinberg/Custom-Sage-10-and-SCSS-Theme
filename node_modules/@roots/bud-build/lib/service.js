var _a, _b, _c;
import { __decorate, __metadata } from "tslib";
import { Service } from '@roots/bud-framework/service';
import { bind } from '@roots/bud-support/decorators';
import isFunction from '@roots/bud-support/lodash/isFunction';
import isUndefined from '@roots/bud-support/lodash/isUndefined';
import { register } from './handlers/register.js';
import { Item } from './item/index.js';
import { Loader } from './loader/index.js';
import { Rule } from './rule/index.js';
/**
 * Webpack configuration builder class
 */
export class Build extends Service {
    constructor() {
        super(...arguments);
        /**
         * @public
         */
        this.config = {};
        /**
         * Registered loaders
         *
         * @public
         */
        // @ts-ignore
        this.loaders = {};
        /**
         * Registered rules
         *
         * @public
         */
        // @ts-ignore
        this.rules = {};
        /**
         * Registered items
         *
         * @public
         */
        // @ts-ignore
        this.items = {};
        /**
         * Service register event
         *
         * @remarks
         * `loaders`, `items`, and `rules` are instantiated dumbly
         * because it is painful to think about how to map the typings..
         *
         * @public
         * @decorator `@bind`
         */
        this.register = register.bind(this);
    }
    /**
     * Make webpack configuration
     *
     * @public
     * @decorator `@bind`
     */
    async make() {
        this.app.log(`bud.build.make called`);
        try {
            await this.app.hooks.fire(`build.before`);
        }
        catch (error) {
            throw error;
        }
        await import(`./config/index.js`).then(async (records) => await Promise.all(Object.entries(records).map(async ([prop, factory]) => {
            try {
                const value = await factory(this.app);
                if (isUndefined(value))
                    return;
                this.config[prop] = value;
                this.logger.success(`built`, prop);
            }
            catch (error) {
                throw error;
            }
        })));
        this.logger.success(`configuration successfully built`);
        await this.app.hooks.fire(`build.after`);
        return this.config;
    }
    /**
     * Set Rule
     *
     * @param name - Rule key
     * @param options - Rule constructor properties
     * @returns the Rule
     *
     * @public
     * @decorator `@bind`
     */
    setRule(name, input) {
        this.rules[name] =
            input instanceof Rule
                ? input
                : isFunction(input)
                    ? input(this.makeRule())
                    : this.makeRule(input);
        this.logger.success(`set rule:`, name);
        this.logger.info(`\n`, this.rules[name]);
        return this;
    }
    /**
     * Make Rule
     *
     * @param options - rule constructor properties
     * @returns the rule
     *
     * @public
     * @decorator `@bind`
     */
    makeRule(options) {
        return new Rule(() => this.app, options);
    }
    getLoader(name) {
        if (!this.loaders[name])
            this.logger.error(`loader ${name} was requested but is not registered`);
        return this.loaders[name];
    }
    /**
     * Set Loader
     *
     * @param name - Loader key
     * @param definition - Loader constructor properties
     * @returns the Loader
     *
     * @public
     * @decorator `@bind`
     */
    setLoader(name, definition) {
        const loader = isUndefined(definition)
            ? this.makeLoader(name)
            : definition instanceof Loader
                ? definition
                : this.makeLoader(definition);
        this.loaders[name] = loader;
        this.logger.info(`set loader`, loader);
        return this;
    }
    /**
     * Make Loader
     *
     * @param options - rule constructor properties
     * @returns the rule
     *
     * @public
     * @decorator `@bind`
     */
    makeLoader(src) {
        return new Loader(() => this.app, src);
    }
    getItem(name) {
        if (!this.items[name])
            this.logger.error(`loader ${name} was requested but is not registered`);
        return this.items[name];
    }
    /**
     * Set Item
     *
     * @param name - Item key
     * @param options - Item constructor properties
     * @returns the Item
     *
     * @public
     * @decorator `@bind`
     */
    setItem(name, options) {
        const maybeOptionsCallback = isUndefined(options)
            ? { ident: name, loader: name }
            : options;
        const item = isFunction(maybeOptionsCallback)
            ? maybeOptionsCallback(this.makeItem())
            : this.makeItem(maybeOptionsCallback);
        this.items[name] = item;
        this.logger.info(`set item`, item);
        return this;
    }
    /**
     * Make Item
     *
     * @param options - rule constructor properties
     * @returns the rule
     *
     * @public
     * @decorator `@bind`
     */
    makeItem(options) {
        return new Item(() => this.app, options);
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Build.prototype, "make", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_a = typeof K !== "undefined" && K) === "function" ? _a : Object, Object]),
    __metadata("design:returntype", Object)
], Build.prototype, "setRule", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Rule)
], Build.prototype, "makeRule", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Loader)
], Build.prototype, "getLoader", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof K !== "undefined" && K) === "function" ? _b : Object, Object]),
    __metadata("design:returntype", Object)
], Build.prototype, "setLoader", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Loader)
], Build.prototype, "makeLoader", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Item)
], Build.prototype, "getItem", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof K !== "undefined" && K) === "function" ? _c : Object, Object]),
    __metadata("design:returntype", Object)
], Build.prototype, "setItem", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Item)
], Build.prototype, "makeItem", null);
//# sourceMappingURL=service.js.map