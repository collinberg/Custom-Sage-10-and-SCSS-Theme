var _a;
import { __decorate, __metadata } from "tslib";
import { Extension } from '@roots/bud-framework/extension';
import { bind, dependsOn, expose, label, options, } from '@roots/bud-framework/extension/decorators';
import get from '@roots/bud-support/lodash/get';
import isFunction from '@roots/bud-support/lodash/isFunction';
import isUndefined from '@roots/bud-support/lodash/isUndefined';
import defaultConfig from 'tailwindcss/defaultConfig.js';
import pluginUtils from 'tailwindcss/lib/util/pluginUtils.js';
import resolveConfig from 'tailwindcss/resolveConfig.js';
import WebpackVirtualModules from 'webpack-virtual-modules';
/**
 * TailwindCSS support for `@roots/bud`
 *
 * @decorator `@expose`
 * @decorator `@label`
 * @decorator `@dependsOn`
 * @decorator `@options`
 */
let BudTailwindCss = class BudTailwindCss extends Extension {
    constructor() {
        super(...arguments);
        /**
         * Resolved paths
         */
        this.dependencies = {
            tailwindcss: null,
            nesting: null,
        };
    }
    /**
     * Get config path
     */
    get path() {
        return (this.app.context.config[`tailwind.config.js`]?.path ??
            this.app.context.config[`tailwind.config.mjs`]?.path ??
            this.app.context.config[`tailwind.config.cjs`]?.path ??
            this.app.root.context.config[`tailwind.config.js`]?.path ??
            this.app.root.context.config[`tailwind.config.mjs`]?.path ??
            this.app.root.context.config[`tailwind.config.cjs`]?.path);
    }
    getConfig() {
        return this.config ? this.config : this.resolveConfig();
    }
    getTheme() {
        return this.theme;
    }
    /**
     * Get config source module
     */
    async getSource() {
        let config;
        if (this.path) {
            try {
                config = await this.app.module.import(this.path);
                return config;
            }
            catch (error) { }
        }
        return defaultConfig;
    }
    /**
     * Keys that can be imported from `@tailwind` alias
     */
    get importableKeys() {
        return Array.isArray(this.options.generateImports)
            ? this.options.generateImports
            : Object.keys(this.theme);
    }
    /**
     * Resolve a tailwind config value
     * @decorator `@bind`
     */
    resolveThemeValue(key, extendedOnly) {
        const rawValue = get(this.theme, key);
        if (!rawValue) {
            throw new Error(`@roots/bud-tailwindcss: ${key} is not a valid tailwind theme key.`);
        }
        const value = isFunction(rawValue) ? rawValue(pluginUtils) : rawValue;
        if (!value) {
            throw new Error(`@roots/bud-tailwindcss: value for ${key} could not be resolved.`);
        }
        if (!extendedOnly)
            return value;
        const src = this.source?.theme?.extend?.[key];
        if (!src) {
            throw new Error(`The key "${key}" is not extended in your tailwind config.\n\n${JSON.stringify(this.source, null, 2)}`);
        }
        const extended = isFunction(src) ? src(pluginUtils) : src;
        return Object.entries(value).reduce((a, [k, v]) => ({
            ...a,
            ...(Object.keys(extended).includes(k) ? { [k]: v } : {}),
        }), {});
    }
    /**
     * Generate a static module for a tailwind theme key
     * @decorator `@bind`
     */
    makeStaticModule(key) {
        return `export default ${JSON.stringify(get(this.theme, key))}\n`;
    }
    /**
     * Generate import mapping
     * @decorator `@bind`
     */
    async generateImports(imports) {
        this.setOption(`generateImports`, !isUndefined(imports) ? imports : true);
        return this;
    }
    /**
     * `init` callback
     * @decorator `@bind`
     */
    async init() {
        this.dependencies.tailwindcss = await this.resolve(`tailwindcss`);
        this.dependencies.nesting = await this.resolve(`tailwindcss/nesting/index.js`);
        this.source = await this.getSource();
        const resolvedConfig = resolveConfig(this.source);
        if (!resolvedConfig)
            return;
        this.config = { ...resolvedConfig };
        this.theme = { ...(this.config?.theme ?? {}) };
    }
    /**
     * `configAfter` callback
     * @decorator `@bind`
     */
    async configAfter(bud) {
        if (!bud.postcss) {
            throw new Error(`@roots/bud-postcss is required to run @roots/bud-tailwindcss`);
        }
        bud.postcss?.setPlugins({
            nesting: this.dependencies.nesting,
            tailwindcss: [this.dependencies.tailwindcss, this.path],
        });
        this.logger.success(`postcss configured for tailwindcss`);
        if (this.options.generateImports === false)
            return;
        await bud.extensions.add({
            label: `@roots/bud-tailwindcss/virtual-module`,
            make: async () => new WebpackVirtualModules(this.importableKeys.reduce((acc, key) => ({
                ...acc,
                [bud.path(`@src`, `__bud`, `@tailwind`, `${key}.mjs`)]: this.makeStaticModule(key),
            }), {})),
        });
        bud.hooks.async(`build.resolve.alias`, async (aliases = {}) => ({
            ...aliases,
            [`@tailwind`]: `${bud.path(`@src`, `__bud`, `@tailwind`)}`,
        }));
    }
};
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], BudTailwindCss.prototype, "getConfig", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], BudTailwindCss.prototype, "getTheme", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BudTailwindCss.prototype, "getSource", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_a = typeof K !== "undefined" && K) === "function" ? _a : Object, Boolean]),
    __metadata("design:returntype", Object)
], BudTailwindCss.prototype, "resolveThemeValue", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], BudTailwindCss.prototype, "makeStaticModule", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], BudTailwindCss.prototype, "generateImports", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BudTailwindCss.prototype, "init", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function]),
    __metadata("design:returntype", Promise)
], BudTailwindCss.prototype, "configAfter", null);
BudTailwindCss = __decorate([
    label(`@roots/bud-tailwindcss`),
    dependsOn([`@roots/bud-postcss`]),
    expose(`tailwind`),
    options({ generateImports: false })
], BudTailwindCss);
export { BudTailwindCss };
//# sourceMappingURL=index.js.map