import { __decorate } from "tslib";
import BudCommand from '@roots/bud/cli/commands/bud';
import { Command } from '@roots/bud-support/clipanion';
import figures from '@roots/bud-support/figures';
import Ink from '@roots/bud-support/ink';
import prettyFormat from '@roots/bud-support/pretty-format';
import React from '@roots/bud-support/react';
import webpack from '@roots/bud-support/webpack';
import { Error } from '../components/Error.js';
import { dry } from '../decorators/command.dry.js';
/**
 * `bud doctor` command
 *
 * @public
 * @decorator `@dry`
 */
let BudDoctorCommand = class BudDoctorCommand extends BudCommand {
    constructor() {
        super(...arguments);
        this.withArguments = async (args) => {
            return { ...args, cache: false, dry: true };
        };
        this.enabledExtensions = [];
        this.disabledExtensions = [];
        this.entrypoints = [];
    }
    /**
     * Execute command
     *
     * @public
     * @decorator `@bind`
     */
    async execute() {
        await this.makeBud(this);
        await this.run(this);
        await this.renderOnce(React.createElement(Ink.Box, { marginTop: 1 },
            React.createElement(Ink.Text, { color: "magenta" }, this.bud.context.manifest.name
                ? this.bud.context.manifest.name
                : this.bud.path())));
        await this.renderOnce(React.createElement(Ink.Box, { flexDirection: "column" },
            React.createElement(Ink.Text, { color: "blue" }, "Core modules"),
            await this.packageCheck(`@roots/bud-api`),
            await this.packageCheck(`@roots/bud-build`),
            await this.packageCheck(`@roots/bud-cache`),
            await this.packageCheck(`@roots/bud-dashboard`),
            await this.packageCheck(`@roots/bud-extensions`),
            await this.packageCheck(`@roots/bud-framework`),
            await this.packageCheck(`@roots/bud-hooks`),
            await this.packageCheck(`@roots/bud-server`),
            await this.packageCheck(`@roots/bud-support`)));
        await this.renderOnce(React.createElement(Ink.Box, { flexDirection: "column" },
            React.createElement(Ink.Text, { color: "blue" }, "Paths"),
            React.createElement(Ink.Text, null,
                "project: ",
                this.bud.path()),
            React.createElement(Ink.Text, null,
                "input:",
                ` `,
                this.bud.path(`@src`).replace(this.bud.path(), `@project`)),
            React.createElement(Ink.Text, null,
                "output:",
                ` `,
                this.bud.path(`@dist`).replace(this.bud.path(), `@project`)),
            React.createElement(Ink.Text, null,
                "storage:",
                ` `,
                this.bud.path(`@storage`).replace(this.bud.path(), `@project`)),
            React.createElement(Ink.Text, null,
                "cache: ",
                ` `,
                "@project/",
                this.bud.relPath(this.bud.cache.cacheDirectory))));
        if (await this.bud.fs.exists(this.bud.cache.cacheDirectory)) {
            await this.renderOnce(React.createElement(Ink.Box, { flexDirection: "column" },
                React.createElement(Ink.Text, { color: "yellow" },
                    "Detected compilation cache:",
                    ` `,
                    this.bud.relPath(this.bud.cache.cacheDirectory)),
                React.createElement(Ink.Text, null, "If you are experiencing issues with bud.js you may want to delete this directory and try again."),
                React.createElement(Ink.Text, null,
                    "To delete this directory with the CLI run",
                    ` `,
                    React.createElement(Ink.Text, { color: "green" }, "`bud clean`")),
                React.createElement(Ink.Text, null,
                    "Or, use the ",
                    React.createElement(Ink.Text, { color: "green" }, "`--force`"),
                    " flag on your next build")));
        }
        await this.renderOnce(React.createElement(Ink.Box, { flexDirection: "column" },
            React.createElement(Ink.Text, { color: "blue" }, "Mode"),
            React.createElement(Ink.Text, null, this.bud.mode)));
        const configFiles = (this.bud.context.config ? Object.values(this.bud.context.config) : []).filter(({ bud }) => bud);
        if (configFiles.length) {
            await this.renderOnce(React.createElement(Ink.Box, { flexDirection: "column" },
                React.createElement(Ink.Text, { color: "blue" }, "Bud configuration files"),
                configFiles.map(({ name, path }, i) => (React.createElement(Ink.Box, { key: i },
                    React.createElement(Ink.Text, null,
                        "- ",
                        name),
                    React.createElement(Ink.Text, null, ` `),
                    React.createElement(Ink.Text, { dimColor: true }, path.replace(this.bud.context.basedir, `.`)))))));
        }
        else {
            await this.renderOnce(React.createElement(Ink.Box, { flexDirection: "column" },
                React.createElement(Ink.Text, { color: "blue" }, "Registered configurations"),
                React.createElement(Ink.Text, { dimColor: true }, "No configuration files found in project")));
        }
        try {
            await this.renderOnce(React.createElement(Ink.Box, { flexDirection: "column" },
                React.createElement(Ink.Text, { color: "blue" }, "Config API calls"),
                !this.bud.api.trace.length ? (React.createElement(Ink.Text, { dimColor: true }, "No config calls logged")) : (this.bud.api.trace.map(([fn, args], i) => (React.createElement(Ink.Box, { flexDirection: "row", key: i },
                    React.createElement(Ink.Text, null,
                        "- ",
                        fn),
                    React.createElement(Ink.Text, null, ` `),
                    React.createElement(Ink.Text, { dimColor: true }, args.map(this.bud.fs.json.stringify).join(`, `))))))));
        }
        catch (error) {
            await this.renderOnce(React.createElement(Error, { label: "Error analyzing called functions", message: error.message ?? error }));
        }
        try {
            this.configuration = await this.bud.build.make();
            this.entrypoints = this.configuration.entry
                ? Object.entries(this.configuration.entry)
                : [];
            await Promise.all(Object.entries(this.bud.extensions.repository).map(async ([name, extension]) => {
                if (await extension.isEnabled()) {
                    return this.enabledExtensions.push([name, extension]);
                }
                return this.disabledExtensions.push([name, extension]);
            }));
        }
        catch (error) {
            await this.renderOnce(React.createElement(Error, { label: error.name ?? `Configuration error`, message: error.message ?? error }));
        }
        if (this.bud.env) {
            try {
                await this.renderOnce(React.createElement(Ink.Box, { flexDirection: "column" },
                    React.createElement(Ink.Text, { color: "blue" }, "Environment"),
                    this.bud.env.getEntries().map(([key, value]) => {
                        return (React.createElement(Ink.Box, { key: key, flexDirection: "row" },
                            React.createElement(Ink.Text, null, key),
                            React.createElement(Ink.Text, null, ` `),
                            React.createElement(Ink.Text, { dimColor: true }, typeof value === `string`
                                ? `************`
                                : typeof value)));
                    })));
            }
            catch (error) {
                await this.renderOnce(React.createElement(Error, { label: "Environment error", message: error.message }));
            }
        }
        if (this.enabledExtensions) {
            try {
                await this.renderOnce(React.createElement(Ink.Box, { flexDirection: "column" },
                    React.createElement(Ink.Text, { color: "blue" }, "Enabled extensions"),
                    this.mapExtensions(this.enabledExtensions)));
                await this.renderOnce(React.createElement(Ink.Box, { flexDirection: "column" },
                    React.createElement(Ink.Text, { color: "blue" }, "Disabled extensions"),
                    this.mapExtensions(this.disabledExtensions)));
            }
            catch (error) {
                await this.renderOnce(React.createElement(Error, { label: "Extensions", message: error.message ?? error }));
            }
        }
        if (this.entrypoints) {
            await this.renderOnce(React.createElement(Ink.Box, { flexDirection: "column" },
                React.createElement(Ink.Text, { color: "blue" }, "Entrypoints"),
                this.mapEntrypoints(this.entrypoints)));
        }
        if (this.entrypoints.length === 1 &&
            this.entrypoints[0][0] === `main` &&
            this.entrypoints[0][1].import[0] === `index` &&
            !(await this.bud.fs.exists(this.bud.path(`@src/index.js`)))) {
            await this.renderOnce(React.createElement(Error, { label: "Can't resolve application entrypoint", message: `No entrypoint was specified and there is also no file resolvable at \`${this.bud.relPath(`@src/index.js`)}\`. Either specify an entrypoint or create a file at \`${this.bud.relPath(`@src/index.js`)}\`.` }));
        }
        if (this.mode === `development`) {
            await this.renderOnce(React.createElement(Ink.Box, { flexDirection: "column" },
                React.createElement(Ink.Text, { color: "blue" }, "Development server"),
                React.createElement(Ink.Box, { flexDirection: "row" },
                    React.createElement(Ink.Text, null, "URL:"),
                    React.createElement(Ink.Text, null, this.bud.hooks
                        .filter(`dev.url`, new URL(`http://0.0.0.0:3000`))
                        .toString())),
                this.bud.hooks
                    .filter(`dev.middleware.enabled`)
                    .includes(`proxy`) ? (React.createElement(Ink.Box, { flexDirection: "row" },
                    React.createElement(Ink.Text, null, "Proxy:"),
                    React.createElement(Ink.Text, null, this.bud.hooks
                        .filter(`dev.middleware.proxy.options.target`, new URL(`http://0.0.0.0:8000`))
                        .toString()))) : null,
                React.createElement(Ink.Box, { flexDirection: "column" },
                    React.createElement(Ink.Text, null, "Client scripts:"),
                    [...this.bud.hooks.filter(`dev.client.scripts`, new Set([]))]
                        .map(fn => fn(this.bud))
                        .map((script, key) => {
                        return React.createElement(Ink.Text, { key: key },
                            "- ",
                            script);
                    }))));
        }
        try {
            webpack.validate(this.configuration);
            await this.renderOnce(React.createElement(Ink.Box, null,
                React.createElement(Ink.Text, { color: "green" }, "\u2705 webpack validated configuration")));
        }
        catch (error) {
            await this.renderOnce(React.createElement(Ink.Box, null,
                React.createElement(Ink.Text, { color: "red" },
                    "\u274C ",
                    error?.message ?? error)));
        }
    }
    mapExtensions(extensions) {
        return extensions.map(([name, extension]) => (React.createElement(Ink.Box, { key: `extension-${name}`, flexDirection: "column" },
            React.createElement(Ink.Text, { color: "white" },
                "- ",
                name))));
    }
    mapEntrypoints(entrypoints) {
        return entrypoints.map(([name, entry]) => {
            return (React.createElement(Ink.Box, { key: `${name}-entry`, flexDirection: "column" },
                React.createElement(Ink.Text, null, name),
                React.createElement(Ink.Text, { dimColor: true }, prettyFormat(entry, {
                    printBasicPrototype: false,
                }))));
        });
    }
    async ls(path) {
        const formatFilesArray = (files) => {
            return files.map((file, id) => {
                return (React.createElement(Ink.Box, { key: `${file.name}-file`, flexDirection: file.children ? `column` : `row` },
                    React.createElement(Ink.Text, null,
                        React.createElement(Ink.Text, { dimColor: true }, file.children ? figures.ellipsis : figures.pointerSmall),
                        ` `,
                        file.name),
                    file.children ? (React.createElement(Ink.Box, { paddingLeft: 2, flexDirection: "column" }, formatFilesArray(file.children))) : null));
            });
        };
        const files = await this.bud.fs.inspectTree(path);
        return files.children ? formatFilesArray(files.children) : null;
    }
    async packageCheck(signifier) {
        const manifest = await this.bud.module.getManifestPath(signifier);
        const { version: packageVersion } = await this.bud.fs.read(manifest);
        if (packageVersion !== this.bud.context.bud.version) {
            return (React.createElement(Error, { label: signifier, message: `${signifier} is not installed at the same version as @roots/bud (required: ${this.bud.context.bud.version}, installed: ${packageVersion}). Your installation may be corrupted; consider reinstalling with the \`--force\` flag.` }));
        }
        else {
            return (React.createElement(Ink.Text, null,
                React.createElement(Ink.Text, { color: "green" },
                    signifier,
                    " meets requirements"),
                ` `,
                "(required:",
                ` `,
                this.bud.context.bud.version,
                ", installed: ",
                packageVersion,
                ")"));
        }
    }
};
BudDoctorCommand.paths = [[`doctor`]];
BudDoctorCommand.usage = Command.Usage({
    description: `Check project for common errors`,
    details: `\
The \`bud doctor\` command will:

1. validate the \`production\` configuration with \`webpack\`

\`webpack\` exports a \`validate\` function which is used by this command to verify that
the configuration matches the \`webpack\` configuration schema.

2. check the \`dependencies\` and \`devDependencies\` in the \`package.json\` file.

In general, \`bud.js\` dependencies should be kept at the same version. This script doesn't account
for a lot of edge cases so it might return a false positive.
`,
    examples: [
        [`Check compiled configuration against webpack`, `$0 doctor`],
    ],
});
BudDoctorCommand = __decorate([
    dry
], BudDoctorCommand);
export default BudDoctorCommand;
//# sourceMappingURL=bud.doctor.js.map