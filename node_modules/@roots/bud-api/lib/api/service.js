import { __decorate, __metadata } from "tslib";
import { ServiceContainer } from '@roots/bud-framework/service';
import chalk from '@roots/bud-support/chalk';
import { bind } from '@roots/bud-support/decorators';
import isFunction from '@roots/bud-support/lodash/isFunction';
import { factory } from '../facade/facade.factory.js';
import * as methods from '../methods/index.js';
/**
 * API service
 *
 * @remarks
 * Binds facade methods to the framework and provides a way to list them,
 * call them, and otherwise manipulate them.
 */
export class Api extends ServiceContainer {
    constructor() {
        super(...arguments);
        /**
         * Called methods
         *
         * @public
         */
        this.trace = [];
        /**
         * Queued method calls
         *
         * @public
         */
        this.queue = [];
    }
    /**
     * `bootstrap` callback
     *
     * @public
     * @decorator `@bind`
     */
    async bootstrap(_app) {
        Object.entries(methods).map(([k, v]) => this.bindFacade(k, v));
    }
    /**
     * Bind a synchronous facade for use in configs
     *
     * @public
     * @decorator `@bind`
     */
    bindFacade(name, fn) {
        if (!isFunction(fn)) {
            throw new Error(`bud.api.bindFacade error: ${name} is not a function`);
        }
        this.set(name, fn.bind(this.app));
        this.app.bindMethod(name, factory(this.app, name));
    }
    /**
     * Call an api method directly
     *
     * @public
     * @decorator `@bind`
     */
    async call(name, args) {
        this.app.log(chalk.blue(name), args);
        if (!this.has(name)) {
            throw new Error(`bud.api.call error: ${name} is not a function`);
        }
        try {
            return await this.get(name).call(this.app, ...args);
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * Execute all queued method calls
     *
     * @public
     * @decorator `@bind`
     */
    async processQueue() {
        const stack = [...this.queue];
        this.queue = [];
        await Promise.all(stack.map(async (value) => {
            if (!value) {
                this.logger.warn(`api.processQueue: undefined api call`);
                return;
            }
            const [name, args] = value;
            await this.call(name, args);
            this.trace.push([name, args]);
        }));
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function]),
    __metadata("design:returntype", Promise)
], Api.prototype, "bootstrap", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", void 0)
], Api.prototype, "bindFacade", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Array]),
    __metadata("design:returntype", Promise)
], Api.prototype, "call", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Api.prototype, "processQueue", null);
//# sourceMappingURL=service.js.map