import { __decorate, __metadata } from "tslib";
import BudCommand from '@roots/bud/cli/commands/bud';
import { Command, Option } from '@roots/bud-support/clipanion';
import { bind } from '@roots/bud-support/decorators';
import isUndefined from '@roots/bud-support/lodash/isUndefined';
import * as t from '@roots/bud-support/typanion';
/**
 * Build command
 */
export default class BudBuildCommand extends BudCommand {
    constructor() {
        super(...arguments);
        this.withBud = async (bud) => {
            if (!isUndefined(this.notifier)) {
                bud.hooks.action(`compiler.after`, async () => {
                    bud.compiler.instance.hooks.done.tap(`bud-cli-notifier`, this.notifier.compilationNotification);
                });
            }
            return bud;
        };
        this.cache = Option.String(`--cache`, undefined, {
            description: `Utilize compiler's filesystem cache`,
            tolerateBoolean: true,
            validator: t.isOneOf([
                t.isLiteral(`filesystem`),
                t.isLiteral(`memory`),
                t.isLiteral(true),
                t.isLiteral(false),
            ]),
            env: `APP_CACHE`,
        });
        this.clean = Option.Boolean(`--clean`, undefined, {
            description: `Clean artifacts and distributables prior to compilation`,
        });
        this.devtool = Option.String(`--devtool`, undefined, {
            description: `Set devtool option`,
            validator: t.isOneOf([
                t.isLiteral(false),
                t.isLiteral(`eval`),
                t.isLiteral(`eval-cheap-source-map`),
                t.isLiteral(`eval-cheap-module-source-map`),
                t.isLiteral(`eval-source-map`),
                t.isLiteral(`cheap-source-map`),
                t.isLiteral(`cheap-module-source-map`),
                t.isLiteral(`source-map`),
                t.isLiteral(`inline-cheap-source-map`),
                t.isLiteral(`inline-cheap-module-source-map`),
                t.isLiteral(`inline-source-map`),
                t.isLiteral(`eval-nosources-cheap-source-map`),
                t.isLiteral(`eval-nosources-cheap-modules-source-map`),
                t.isLiteral(`eval-nosources-source-map`),
                t.isLiteral(`inline-nosources-cheap-source-map`),
                t.isLiteral(`inline-nosources-cheap-module-source-map`),
                t.isLiteral(`inline-nosources-source-map`),
                t.isLiteral(`nosources-cheap-source-map`),
                t.isLiteral(`nosources-cheap-module-source-map`),
                t.isLiteral(`hidden-nosources-cheap-source-map`),
                t.isLiteral(`hidden-nosources-cheap-module-source-map`),
                t.isLiteral(`hidden-nosources-source-map`),
                t.isLiteral(`hidden-cheap-source-map`),
                t.isLiteral(`hidden-cheap-module-source-map`),
                t.isLiteral(`hidden-source-map`),
            ]),
            env: `APP_DEVTOOL`,
        });
        this.editor = Option.String(`--editor`, undefined, {
            description: `Open editor to file containing errors on unsuccessful development build`,
            tolerateBoolean: true,
        });
        this.esm = Option.Boolean(`--esm`, undefined, {
            description: `build as es modules`,
        });
        this.flush = Option.Boolean(`--flush,--force`, undefined, {
            description: `Force clearing bud internal cache`,
        });
        this.hash = Option.Boolean(`--hash`, undefined, {
            description: `Hash compiled filenames`,
        });
        this.html = Option.String(`--html`, undefined, {
            description: `Generate an html template`,
            tolerateBoolean: true,
        });
        this.immutable = Option.Boolean(`--immutable`, undefined, {
            description: `bud.http: immutable module lockfile`,
        });
        this.discover = Option.Boolean(`--discover,--discovery`, undefined, {
            description: `Automatically register extensions`,
        });
        this.manifest = Option.Boolean(`--manifest`, undefined, {
            description: `Generate a manifest of compiled assets`,
        });
        this.minimize = Option.Boolean(`--minimize`, undefined, {
            description: `Minimize compiled assets`,
        });
        this.input = Option.String(`--input,-i,--@src,--src`, undefined, {
            description: `Source directory (relative to project)`,
            env: `APP_PATH_INPUT`,
        });
        this.output = Option.String(`--output,-o,--@dist,--dist`, undefined, {
            description: `Distribution directory (relative to project)`,
            env: `APP_PATH_OUTPUT`,
        });
        this.publicPath = Option.String(`--publicPath`, undefined, {
            description: `public path of emitted assets`,
            env: `APP_PUBLIC_PATH`,
        });
        this.runtime = Option.String(`--runtime`, undefined, {
            description: `Set runtime chunk`,
            validator: t.isOneOf([
                t.isLiteral(`single`),
                t.isLiteral(`multiple`),
                t.isBoolean(),
            ]),
            tolerateBoolean: true,
        });
        this.splitChunks = Option.Boolean(`--splitChunks,--vendor`, undefined, {
            description: `Separate vendor bundle`,
        });
        this.storage = Option.String(`--storage`, undefined, {
            description: `Storage directory (relative to project)`,
            env: `APP_PATH_STORAGE`,
        });
        this.ci = Option.Boolean(`--ci`, undefined, {
            description: `Simple build summaries for CI`,
        });
        this.use = Option.Array(`--use`, undefined, {
            description: `Enable an extension`,
        });
        this.withContext = async (context) => {
            if (this.withSubcommandContext) {
                context = await this.withSubcommandContext(context);
            }
            return context;
        };
        this.withArguments = async (args) => {
            if (this.withSubcommandArguments) {
                args = await this.withSubcommandArguments(args);
            }
            return {
                ...args,
                cache: this.cache,
                ci: this.ci,
                clean: this.clean,
                debug: this.debug,
                discover: this.discover,
                devtool: this.devtool,
                editor: this.editor,
                esm: this.esm,
                flush: this.flush,
                hash: this.hash,
                html: this.html,
                immutable: this.immutable,
                input: this.input,
                output: this.output,
                manifest: this.manifest,
                minimize: this.minimize,
                mode: this.mode,
                publicPath: this.publicPath,
                runtime: this.runtime,
                splitChunks: this.splitChunks,
                storage: this.storage,
                target: this.filter,
                use: this.use,
            };
        };
    }
    /**
     * Execute command
     *
     * @public
     * @decorator `@bind`
     */
    async execute() {
        await this.makeBud(this);
        await this.healthcheck(this);
        await this.run(this);
    }
}
BudBuildCommand.paths = [[`build`]];
BudBuildCommand.usage = Command.Usage({
    category: `build`,
    description: `Compile source assets`,
    details: `\
      \`bud build production\` compiles source assets in \`production\` mode. Run \`bud build production --help\` for usage.

      \`bud build development\` compiles source assets in \`development\` mode and serves updated modules. Run \`bud build development --help\` for usage.

      If you run this command without a configuration file \`bud\` will look for an entrypoint at \`@src/index.js\`.
    `,
    examples: [[`compile source assets`, `$0 build`]],
});
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BudBuildCommand.prototype, "execute", null);
//# sourceMappingURL=bud.build.js.map