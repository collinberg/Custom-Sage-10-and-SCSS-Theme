import { __decorate, __metadata } from "tslib";
import { Bud, Extension } from '@roots/bud-framework';
import { bind, label, options, plugin, } from '@roots/bud-framework/extension/decorators';
import isUndefined from '@roots/bud-support/lodash/isUndefined';
import { Plugin } from '@roots/bud-support/webpack-manifest-plugin';
/**
 * `webpack-manifest-plugin` adapter
 *
 * @public
 * @decorator `@label`
 * @decorator `@plugin`
 * @decorator `@options`
 */
let BudManifestExtension = class BudManifestExtension extends Extension {
    /**
     * `when` callback
     *
     * @remarks
     * Returns `feature.manifest` hook result
     *
     * @public
     * @decorator `@bind`
     */
    async when(bud) {
        if (!bud.isCLI())
            return bud.hooks.filter(`feature.manifest`, true);
        if (!isUndefined(bud.context.args.manifest))
            return bud.context.args.manifest;
        return bud.hooks.filter(`feature.manifest`, true);
    }
};
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Bud]),
    __metadata("design:returntype", Promise)
], BudManifestExtension.prototype, "when", null);
BudManifestExtension = __decorate([
    label(`@roots/bud-extensions/webpack-manifest-plugin`),
    plugin(Plugin),
    options({
        fileName: `manifest.json`,
        writeToFileEmit: true,
        publicPath: ({ hooks }) => (hooks.filter(`build.output.publicPath`) ?? ``).replace(`auto`, ``),
    })
], BudManifestExtension);
export default BudManifestExtension;
//# sourceMappingURL=index.js.map