import type { Instance as Signale } from '@roots/bud-support/signale';
import type { Bud } from '../bud.js';
import type { Modules } from '../index.js';
import type { ApplyPluginConstructor } from './decorators/plugin.js';
export type Options<T = Record<string, any>> = {
    [K in keyof T as `${K & string}`]?: T[K];
};
export type OptionsMap<MappedOptions extends Options> = {
    [K in keyof MappedOptions as `${K & string}`]?: ((app: Bud) => MappedOptions[K]) | MappedOptions[K];
};
/**
 * Webpack plugin.
 */
export interface ApplyPlugin {
    /**
     * Loose defined
     *
     * @public
     */
    [key: string]: any;
    /**
     * Apply callback
     *
     * @see {@link https://webpack.js.org/contribute/writing-a-plugin/#basic-plugin-architecture}
     *
     * @public
     */
    apply: (...args: any[]) => unknown;
}
export interface Constructor {
    new (...args: any[]): Extension | ApplyPlugin;
}
export type ExtensionLiteral = {
    [K in keyof Extension]?: Extension[K];
};
/**
 * Bud extension
 */
export declare class Extension<ExtensionOptions extends Options = Options, Plugin extends ApplyPlugin = ApplyPlugin> {
    /**
     * Loose definition
     *
     * @public
     */
    [key: string]: any;
    /**
     * Application
     *
     * @internal
     */
    _app: () => Bud;
    /**
     * Application accessor
     *
     * @public
     */
    app: Bud;
    /**
     * Extension is enabled
     */
    enabled?: boolean;
    /**
     * Extension options
     *
     * @internal
     */
    optionsMap: OptionsMap<ExtensionOptions>;
    /**
     * Extension options
     *
     * @readonly
     * @public
     */
    readonly options: ExtensionOptions;
    /**
     * Extension meta
     *
     * @public
     */
    meta: {
        init: boolean;
        register: boolean;
        boot: boolean;
        configAfter: boolean;
        buildBefore: boolean;
        buildAfter: boolean;
    };
    /**
     * The module name
     *
     * @public
     */
    label: keyof Modules & string;
    /**
     * @public
     */
    logger: Signale;
    /**
     * Depends on
     *
     * @public
     */
    dependsOn?: Set<keyof Modules & string>;
    /**
     * Depends on (optional)
     *
     * @public
     */
    dependsOnOptional?: Set<`${keyof Modules & string}`>;
    /**
     * Function returning a boolean indicating if the {@link Extension} should be utilized.
     *
     * @remarks
     * By default returns {@link Extension.enabled}
     *
     * @public
     */
    when(_app: Bud, _options?: ExtensionOptions): Promise<boolean>;
    /**
     * `init` callback
     *
     * @param options - Extension options
     * @param app - Bud instance
     *
     * @public
     */
    init?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `register` callback
     *
     * @param options - Extension options
     * @param app - Bud instance
     *
     * @public
     */
    register?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `boot` callback
     *
     * @param options - Extension options
     * @param app - Bud instance
     *
     * @public
     */
    boot?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `configAfter` callback
     *
     * @public
     */
    configAfter?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `buildBefore` callback
     *
     * @public
     */
    buildBefore?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `buildAfter` callback
     *
     * @public
     */
    buildAfter?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `make` callback
     *
     * @param options - Extension options
     * @param app - Bud instance
     *
     * @public
     */
    make?(app: Bud, options?: ExtensionOptions): Promise<Plugin>;
    /**
     * Plugin constructor
     *
     * @public
     */
    plugin?: ApplyPluginConstructor;
    /**
     * Class constructor
     *
     * @public
     */
    constructor(app: Bud);
    /**
     * `init` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    _init(): Promise<void>;
    /**
     * `register` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    _register(): Promise<void>;
    /**
     * `boot` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    _boot(): Promise<void>;
    /**
     * `buildBefore` callback handler
     *
     * @public
     */
    _buildBefore(): Promise<void>;
    /**
     * `buildAfter` callback handler
     *
     * @public
     */
    _buildAfter(): Promise<void>;
    /**
     * `configAfter` callback handler
     *
     * @public
     */
    _configAfter(): Promise<void>;
    /**
     * `make` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    _make(): Promise<false | import("./decorators/plugin.js").ApplyPlugin | this>;
    /**
     * Get extension options
     *
     * @public
     * @decorator `@bind`
     */
    getOptions(): ExtensionOptions;
    /**
     * Set extension options
     *
     * @public
     * @decorator `@bind`
     */
    setOptions(value: ExtensionOptions | ((options: ExtensionOptions) => ExtensionOptions)): this;
    /**
     * Get extension option
     *
     * @public
     * @decorator `@bind`
     */
    getOption<K extends keyof ExtensionOptions & string>(key: K): ExtensionOptions[K];
    /**
     * Set extension option
     *
     * @public
     * @decorator `@bind`
     */
    setOption<K extends keyof ExtensionOptions & string>(key: K, value: ExtensionOptions[K]): this;
    /**
     * Normalize options to functions
     *
     * @public
     * @decorator `@bind`
     */
    toOptionsMap<K extends keyof ExtensionOptions & string>(funcMap: OptionsMap<ExtensionOptions>, [key, value]: [K & string, ExtensionOptions[K & string]]): OptionsMap<ExtensionOptions>;
    /**
     * Get options from function map
     *
     * @public
     * @decorator `@bind`
     */
    fromOptionsMap<K extends keyof OptionsMap<ExtensionOptions>>(options: ExtensionOptions, [key, value]: [K, OptionsMap<ExtensionOptions>[K]]): ExtensionOptions;
    /**
     * Assign properties from an object
     *
     * @public
     * @decorator `@bind`
     */
    fromObject(extensionObject: ExtensionLiteral): this;
    /**
     * Returns true if extension property is set
     *
     * @param key - property name
     * @returns true if property exists on extension
     *
     * @public
     * @decorator `@bind`
     */
    has<K extends `${keyof Extension}`>(key: K): boolean;
    /**
     * Returns true if extension property is set and is a function
     *
     * @param key - property name
     * @returns true if property exists on extension
     *
     * @public
     * @decorator `@bind`
     */
    isFunction<K extends `${keyof Extension}`>(key: K): boolean;
    /**
     * Resolve module using `import.meta.resolve` api
     *
     * @remarks
     * Uses `import-meta-resolve` (npm package).
     * Will transition to node `import.meta.resolve` api when it is marked
     * non-experimental. It currently requires a flag to enable.
     *
     * @public
     * @decorator `@bind`
     */
    resolve(signifier: string, context?: string): Promise<string>;
    /**
     * Import ESM module
     *
     * @public
     * @decorator `@bind`
     */
    import<T = any>(signifier: string, context?: URL | string): Promise<T | undefined>;
    /**
     * Disable extension
     *
     * @public
     * @decorator `@bind`
     */
    disable(): void;
    /**
     * Enable extension
     *
     * @public
     * @decorator `@bind`
     */
    enable(enabled?: boolean): this;
    /**
     * Value determining if the extension should be utilized
     *
     * @public
     * @decorator `@bind`
     */
    isEnabled(): Promise<boolean>;
}
//# sourceMappingURL=index.d.ts.map