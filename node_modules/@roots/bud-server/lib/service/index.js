import { __decorate, __metadata } from "tslib";
import { Service } from '@roots/bud-framework/service';
import { inject } from '@roots/bud-server/inject';
import { bind } from '@roots/bud-support/decorators';
/**
 * Server service class
 */
export class Server extends Service {
    constructor() {
        super(...arguments);
        /**
         * Available middleware
         * @public
         */
        this.availableMiddleware = {
            proxy: `@roots/bud-server/middleware/proxy`,
            cookie: `@roots/bud-server/middleware/cookie`,
            hot: `@roots/bud-server/middleware/hot`,
            dev: `@roots/bud-server/middleware/dev`,
        };
        /**
         * Applied middleware
         * @public
         */
        this.appliedMiddleware = {};
    }
    /**
     * Utilized middleware
     * @public
     */
    get enabledMiddleware() {
        return this.app.hooks.filter(`dev.middleware.enabled`, [])?.reduce((enabled, key) => ({
            ...enabled,
            [key]: this.availableMiddleware[key],
        }), {});
    }
    /**
     * Development server URL
     */
    get url() {
        return this.app.hooks.filter(`dev.url`, new URL(`http://0.0.0.0:3000`));
    }
    /**
     * External development server URL
     */
    get publicUrl() {
        return this.app.hooks.filter(`dev.publicUrl`, this.url);
    }
    /**
     * `register` callback
     *
     * @public
     * @decorator `@bind`
     * @decorator `@once`
     */
    async register(bud) {
        if (!bud.isDevelopment)
            return;
        this.application = await import(`@roots/bud-support/express`).then(({ default: express }) => express());
        this.watcher = await import(`@roots/bud-server/server/watcher`).then(({ Watcher }) => new Watcher(() => bud));
        bud.hooks.on(`dev.client.scripts`, await import(`@roots/bud-server/hooks`).then(({ devClientScripts }) => devClientScripts.callback));
        this.application.set(`x-powered-by`, false);
        bud.hooks.action(`server.before`, this.setConnection.bind(this), this.injectScripts.bind(this), bud.compiler.compile.bind(bud.compiler), this.applyMiddleware.bind(this), this.watcher.watch.bind(this.watcher));
    }
    /**
     * Set connection
     * @public
     * @decorator `@bind`
     * @decorator `@once`
     */
    async setConnection(bud) {
        const isHttps = this.url.protocol === `https:`;
        this.connection = await bud.module
            .import(isHttps
            ? `@roots/bud-server/server/https`
            : `@roots/bud-server/server/http`)
            .then(({ Server }) => new Server(bud));
    }
    /**
     * Inject scripts
     * @public
     * @decorator `@bind`
     * @decorator `@once`
     */
    async injectScripts() {
        const injectOn = async (instance) => inject(instance, Array.from(this.app.hooks.filter(`dev.client.scripts`, new Set([]))));
        this.app.hasChildren
            ? Object.values(this.app.children).map(injectOn)
            : injectOn(this.app);
    }
    /**
     * Apply middleware
     *
     * @public
     * @decorator `@bind`
     * @decorator `@once`
     */
    async applyMiddleware() {
        if (this.app.isCLI() && this.app.context.args.dry)
            return;
        try {
            await Promise.all(Object.entries(this.enabledMiddleware).map(async ([key, signifier]) => {
                if (this.app.isCLI() &&
                    this.app.context.args.hot === false &&
                    key === `hot`)
                    return;
                try {
                    /** import middleware */
                    const { factory } = await this.app.module.import(signifier);
                    /** save reference to middleware instance */
                    this.appliedMiddleware[key] = factory(this.app);
                    /** apply middleware */
                    this.application.use(this.appliedMiddleware[key]);
                }
                catch (error) {
                    this.logger.error(`Failed to apply middleware: ${key}`, error);
                }
            }));
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * Run development server
     *
     * @public
     * @decorator `@bind`
     */
    async run() {
        await this.app.hooks.fire(`server.before`);
        if (!this.app.isCLI() || !this.app.context.args.dry) {
            await this.connection.createServer(this.application);
            await this.connection.listen();
        }
        await this.app.hooks.fire(`server.after`);
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function]),
    __metadata("design:returntype", Promise)
], Server.prototype, "register", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function]),
    __metadata("design:returntype", Promise)
], Server.prototype, "setConnection", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Server.prototype, "injectScripts", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Server.prototype, "applyMiddleware", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Server.prototype, "run", null);
//# sourceMappingURL=index.js.map