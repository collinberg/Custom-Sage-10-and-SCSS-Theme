import { __decorate, __metadata } from "tslib";
import { createHash } from 'node:crypto';
import { Service } from '@roots/bud-framework/service';
import { bind } from '@roots/bud-support/decorators';
import isString from '@roots/bud-support/lodash/isString';
import join from '@roots/bud-support/lodash/join';
import InvalidateCacheExtension from './invalidate-cache-extension/index.js';
/**
 * Cache service class
 */
export default class Cache extends Service {
    constructor() {
        super(...arguments);
        /**
         * Enabled
         *
         * @public
         */
        this.enabled = true;
    }
    /**
     * Type
     *
     * @public
     */
    get name() {
        return this.app.hooks.filter(`build.cache.name`, this.app.hooks.filter(`build.name`, this.app.context.label));
    }
    set name(name) {
        this.app.hooks.on(`build.cache.name`, name);
    }
    /**
     * Type
     *
     * @public
     */
    get type() {
        return this.app.hooks.filter(`build.cache.type`, this.app.isCLI() && isString(this.app.context.args.cache)
            ? this.app.context.args.cache
            : `filesystem`);
    }
    set type(type) {
        this.app.hooks.on(`build.cache.type`, type);
    }
    /**
     * version
     *
     * @public
     */
    get version() {
        const args = this.app.fs.json.stringify(this.app.isCLI() ? this.app.context.args : {});
        const files = Object.values(this.app.context.config ?? {}).filter(file => file?.bud && file.sha1);
        return this.app.hooks.filter(`build.cache.version`, createHash(`sha1`)
            .update(join(args, ...files.map(({ module: { sha1 } }) => sha1)))
            .digest(`base64`));
    }
    set version(version) {
        this.app.hooks.on(`build.cache.version`, version);
    }
    /**
     * Cache directory
     *
     * @public
     */
    get cacheDirectory() {
        return this.app.hooks.filter(`build.cache.cacheDirectory`, this.app.path(`@storage`, this.app.label, `cache`, this.app.mode));
    }
    set cacheDirectory(directory) {
        this.app.hooks.on(`build.cache.cacheDirectory`, directory);
    }
    /**
     * Webpack configuration
     *
     * @public
     */
    get configuration() {
        if (this.enabled !== true)
            return false;
        return this.type === `memory`
            ? true
            : {
                name: this.name,
                type: this.type,
                store: `pack`,
                allowCollectingMemory: true,
                cacheDirectory: this.cacheDirectory,
                idleTimeout: 10000,
                idleTimeoutForInitialStore: 0,
                profile: true,
                version: this.version,
            };
    }
    /**
     * `booted` callback
     *
     * @public
     * @decorator `@bind`
     */
    async booted() {
        await this.app.extensions.add(InvalidateCacheExtension);
        this.app.success(`cache initialized`);
    }
    /**
     * Flush cache
     */
    async flush() {
        await this.app.fs.remove(this.cacheDirectory);
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Cache.prototype, "booted", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Cache.prototype, "flush", null);
//# sourceMappingURL=service.js.map